package io.ktor.swagger.experimental

import com.fasterxml.jackson.databind.*
import kotlin.reflect.*
import kotlin.coroutines.experimental.*
import kotlin.coroutines.experimental.intrinsics.*
import kotlinx.coroutines.experimental.*
import io.ktor.application.*
import io.ktor.auth.authenticate
import io.ktor.client.*
import io.ktor.client.call.*
import io.ktor.client.response.*
import io.ktor.http.*
import io.ktor.request.*
import io.ktor.response.*
import io.ktor.routing.*
import java.lang.reflect.*

class HttpException(val code: HttpStatusCode, val description: String = code.description) : RuntimeException(description)

inline fun Parameters.getInt(name: String, verify: (Int) -> Boolean = { true }, default: () -> Int = {0}): Int = (get(name)?.toInt() ?: default()).verifyParam(name, verify)
inline fun <reified T : Any> Parameters.getTyped(name: String, verify: (T) -> Boolean = { true }): T = getTyped(T::class, name).verifyParam(name, verify)
fun <T : Any> Parameters.getTyped(type: KClass<T>, name: String): T = TODO()
fun httpException(code: HttpStatusCode, message: String = code.description): Nothing = throw HttpException(code, message)
fun httpException(code: Int, message: String = "Error $code"): Nothing = throw HttpException(HttpStatusCode(code, message))
inline fun <T> T.verifyParam(name: String, callback: (T) -> Boolean): T { if (!callback(this)) throw IllegalArgumentException("$name"); return this }

interface FeatureClass {
}

interface SwaggerBaseApi {
}

interface SwaggerBaseServer {
}
class ApplicationCallContext(val call: ApplicationCall) : CoroutineContext.Element {
    object KEY : CoroutineContext.Key<ApplicationCallContext>
    override val key: CoroutineContext.Key<*> = KEY
}
suspend fun SwaggerBaseServer.call(): ApplicationCall {
    return coroutineContext[ApplicationCallContext.KEY]?.call ?: error("ApplicationCall not available")
}

annotation class Method(val method: String)
annotation class Body(val name: String)
annotation class Header(val name: String)
annotation class Query(val name: String)
annotation class Path(val name: String) // Reused
annotation class FormData(val name: String)
annotation class Auth(vararg val auths: String)
annotation class Feature(val clazz: KClass<out FeatureClass>)

class PathPattern(val pathPattern: String) {
    companion object {
        val PARAM_REGEX = Regex("\\{(\\w*)\\}")
    }

    val pathNames by lazy { PARAM_REGEX.findAll(pathPattern).map { it.groupValues[1] }.toList() }
    val pathRegex by lazy { Regex(replace { "(\\w+)" }) }

    fun replace(replacer: (String) -> String): String {
        return pathPattern.replace(PARAM_REGEX) { mr -> replacer(mr.groupValues[1] )}
    }

    fun extract(path: String): List<String> {
        return pathRegex.find(path)?.groupValues?.drop(1) ?: listOf()
    }
}

inline fun <reified T : SwaggerBaseApi> createClient(client: HttpClient, rootUrl: String): T =
    createClient(T::class.java, client, rootUrl)

fun <T : SwaggerBaseApi> createClient(clazz: Class<T>, client: HttpClient, rootUrl: String): T {
    val rootUrlTrim = rootUrl.trimEnd('/')

    return Proxy.newProxyInstance(clazz.classLoader, arrayOf(clazz)) { proxy, method, args ->
        val path = method.getDeclaredAnnotation(Path::class.java)?.name
                ?: throw IllegalArgumentException("Can't find path for $method")

        //val params = method.parameters
        val cont = args.lastOrNull() as? Continuation<String>?
                ?: throw RuntimeException("Just implemented suspend functions")

        val pathTrim = path.trimStart('/')
        val pathPattern = PathPattern(pathTrim)

        var argindex = 0
        val pathReplaced = pathPattern.replace { "${args[argindex++]}" }

        launch {
            try {
                val fullUrl = "$rootUrlTrim/$pathReplaced"
                val res = client.call(fullUrl)
                if (res.response.status.value < 400) {
                    cont.resume(res.response.readText())
                } else {
                    throw HttpExceptionWithContent(res.response.status, res.response.readText())
                }
            } catch (e: Throwable) {
                cont.resumeWithException(e)
            }
        }
        COROUTINE_SUSPENDED
    } as T
}

class HttpExceptionWithContent(val code: HttpStatusCode, val content: String) :
    RuntimeException("HTTP ERROR $code : $content")

fun <T : Annotation> java.lang.reflect.Method.getAnnotationInAncestors(clazz: Class<T>): T? {
    val res = this.getAnnotation(clazz) ?: this.getDeclaredAnnotation(clazz)
    if (res != null) return res

    // Try interfaces
    for (ifc in this.declaringClass.interfaces) {
        return ignoreErrors { ifc?.getMethod(name, *parameterTypes)?.getAnnotationInAncestors(clazz) } ?: continue
    }

    // Try ancestor
    return ignoreErrors { this.declaringClass.superclass?.getMethod(name, *parameterTypes) }?.getAnnotationInAncestors(
        clazz
    )
}

suspend fun java.lang.reflect.Method.invokeSuspend(obj: Any?, args: List<Any?>): Any? = suspendCoroutine { c ->
    val method = this@invokeSuspend

    val lastParam = method.parameterTypes.lastOrNull()
    val margs = java.util.ArrayList(args)

    if (lastParam != null && lastParam.isAssignableFrom(Continuation::class.java)) {
        margs += c
    }
    try {
        val result = method.invoke(obj, *margs.toTypedArray())
        if (result != COROUTINE_SUSPENDED) {
            c.resume(result)
        }
    } catch (e: InvocationTargetException) {
        c.resumeWithException(e.targetException)
    } catch (e: Throwable) {
        c.resumeWithException(e)
    }
}

inline fun <T> ignoreErrors(callback: () ->T): T? = try { callback() } catch (e: Throwable) { null }

fun Routing.register(server: SwaggerBaseServer) {
    //println("REGISTERING:")
    for (method in server::class.java.methods) {
        val path = method.getAnnotationInAncestors(Path::class.java)?.name
        val httpMethod = method.getAnnotationInAncestors(Method::class.java)?.method ?: "GET"
        //println("METHOD: $method, $path")
        if (path != null) {
            registerMethod(server, method, path, httpMethod)
        }
    }
}

val java.lang.Class<*>.allTypes: Set<Class<*>> get() {
    val types = LinkedHashSet<Class<*>>()
    val explore = arrayListOf(this)
    while (explore.isNotEmpty()) {
        val item = explore.removeAt(explore.size - 1) ?: continue
        types += item
        explore += item.superclass
        explore += item.interfaces
    }
    return types
}

val java.lang.reflect.Method.parameterAnnotationsInAncestors: List<List<Annotation>> get() {
    val allMethods = this.declaringClass.allTypes.map {
        try { it.getDeclaredMethod(name, *parameterTypes) ?: null } catch (e: NoSuchMethodException) { null }
    }.filterNotNull()
    val out = Array<ArrayList<Annotation>>(parameterTypes.size) { arrayListOf() }.toList()
    for (method in allMethods) {
        for ((index, annotations) in method.parameterAnnotations.withIndex()) {
            out[index] += annotations
        }
    }
    return out
}

enum class Source {
    BODY, QUERY, FORM_DATA, HEADER, PATH
}

fun Route.registerMethod(instance: Any, method: java.lang.reflect.Method, path: String, httpMethod: String) {
    val params = arrayListOf<ParamInfo<*>>()
    for ((ptype, annotations) in method.parameterTypes.zip(method.parameterAnnotationsInAncestors)) {
        // Skip the continuation last argument!
        if (ptype.isAssignableFrom(Continuation::class.java)) continue

        val body = annotations.filterIsInstance<Body>().firstOrNull()?.name
        val query = annotations.filterIsInstance<Query>().firstOrNull()?.name
        val formData = annotations.filterIsInstance<FormData>().firstOrNull()?.name
        val header = annotations.filterIsInstance<Header>().firstOrNull()?.name
        val ppath = annotations.filterIsInstance<Path>().firstOrNull()?.name

        val source = when {
            body != null -> Source.BODY
            query != null -> Source.QUERY
            formData != null -> Source.FORM_DATA
            header != null -> Source.HEADER
            ppath != null -> Source.PATH
            else -> Source.QUERY
        }
        val rname = body ?: query ?: formData ?: header ?: ppath ?: "unknown"

        //println("   - $ptype, ${annotations.toList()}")

        params += ParamInfo(source, rname, ptype)
    }

    //println("METHOD: $instance, $method, $httpMethod, $path")
    //for (param in params) println("  - $param")

    val auths = method.getAnnotationInAncestors(Auth::class.java)?.auths ?: arrayOf()
    if (auths.isNotEmpty()) {
        authenticate(*auths) {
            registerMethodNoAuth(instance, method, path, httpMethod, params)
        }
    } else {
        registerMethodNoAuth(instance, method, path, httpMethod, params)
    }
}

fun Route.registerMethodNoAuth(instance: Any, method: java.lang.reflect.Method, path: String, httpMethod: String, params: List<ParamInfo<*>>) {
    route(path, HttpMethod(httpMethod)) {
        handle {
            val args = arrayListOf<Any?>()
            for (param in params) {
                args += param.get(call)
            }
            withContext(ApplicationCallContext(call)) {
                val result = method.invokeSuspend(instance, args)
                call.respondText(objectMapper.writeValueAsString(result ?: Any()), ContentType.Application.Json)
            }
        }
    }
}

data class ParamInfo<T>(val source: Source, val name: String, val type: Class<T>) {
    fun get(call: ApplicationCall): T {
        return call.getTyped(source, name, type)
    }
}

@PublishedApi
internal val objectMapper = ObjectMapper()

//inline fun <reified T> ApplicationCall.getTyped(source: String, name: String): T =
//        objectMapper.convertValue(getRaw(source, name), T::class.java)

fun <T> ApplicationCall.getTyped(source: Source, name: String, clazz: Class<T>): T {
    return objectMapper.convertValue(getRaw(source, name), clazz)
}

fun ApplicationCall.getRaw(source: Source, name: String): Any? {
    return when (source) {
        Source.PATH -> this.parameters.get(name)
        Source.QUERY -> this.request.queryParameters.get(name)
        Source.BODY -> TODO()
        Source.FORM_DATA -> TODO()
        Source.HEADER -> this.request.header(name)
    }
}